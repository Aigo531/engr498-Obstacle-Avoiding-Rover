#include "stm32l476xx.h"
#include "dc_motor.h"

// GPIO Pin Definitions for Motor Control
#define IN1_PIN (1 << 0)  // PC0
#define IN2_PIN (1 << 1)  // PC1
#define IN3_PIN (1 << 2)  // PC2
#define IN4_PIN (1 << 3)  // PC3

// Function to configure GPIO pins for the motor driver
void configure_motor_pins() {
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOCEN;  // Enable Clock for GPIOC
    GPIOC->MODER &= ~((0x3 << (0 * 2)) | (0x3 << (1 * 2)) | (0x3 << (2 * 2)) | (0x3 << (3 * 2)));  // Clear mode bits
    GPIOC->MODER |= (0x1 << (0 * 2)) | (0x1 << (1 * 2)) | (0x1 << (2 * 2)) | (0x1 << (3 * 2));  // Set mode to output
    GPIOC->OTYPER &= ~((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3));  // Push-pull
    GPIOC->OSPEEDR |= (0x3 << (0 * 2)) | (0x3 << (1 * 2)) | (0x3 << (2 * 2)) | (0x3 << (3 * 2));  // High speed
    GPIOC->PUPDR &= ~((0x3 << (0 * 2)) | (0x3 << (1 * 2)) | (0x3 << (2 * 2)) | (0x3 << (3 * 2)));  // No pull-up, no pull-down
}

// Motor control functions
void motor_stop() {
    GPIOC->ODR &= ~(IN1_PIN | IN2_PIN | IN3_PIN | IN4_PIN);
}

void motor_forward() {
    GPIOC->ODR |= IN1_PIN | IN3_PIN;
    GPIOC->ODR &= ~(IN2_PIN | IN4_PIN);
}

void motor_backward() {
    GPIOC->ODR |= IN2_PIN | IN4_PIN;
    GPIOC->ODR &= ~(IN1_PIN | IN3_PIN);
}

void motor_turn_left() {
    GPIOC->ODR |= IN1_PIN;
    GPIOC->ODR &= ~(IN2_PIN | IN3_PIN | IN4_PIN);
}

void motor_turn_right() {
    GPIOC->ODR |= IN3_PIN;
    GPIOC->ODR &= ~(IN1_PIN | IN2_PIN | IN4_PIN);
}

void control_logic(float left_distance, float right_distance, float current_distance) {
    if (current_distance < 10.0) {
        motor_stop();
        delay(300);  // Delay for 300 ms
        motor_backward();  // Reverse the robot
        delay(1000);  // Move backward for a short duration

        // Check distances to decide the next move
        if (left_distance > right_distance) {
            motor_turn_left();
        } else {
            motor_turn_right();
        }
    } else {
        motor_forward();
    }
}

