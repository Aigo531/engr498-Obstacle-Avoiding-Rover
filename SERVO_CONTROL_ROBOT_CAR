#include "stm32l476xx.h"
#include "dc_motor.h"

// GPIO Pin Definitions for Motor Control
#define IN1_PIN (1 << 0)  // PC0
#define IN2_PIN (1 << 1)  // PC1
#define IN3_PIN (1 << 2)  // PC2
#define IN4_PIN (1 << 3)  // PC3

// Timer setup for PWM control
void setup_pwm_timers() {
    // Enable clock for TIM1 and TIM3
    RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;
    RCC->APB1ENR1 |= RCC_APB1ENR1_TIM3EN;
    
    // Configure PWM mode for TIM1 Channel 1 and TIM3 Channel 1
    TIM1->CCMR1 |= TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2;  // PWM mode 1 on Channel 1
    TIM3->CCMR1 |= TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2;  // PWM mode 1 on Channel 1
    
    // Set output to active high
    TIM1->CCER |= TIM_CCER_CC1E;
    TIM3->CCER |= TIM_CCER_CC1E;
    
    // Set prescaler and auto-reload for desired PWM frequency and duty cycle
    TIM1->PSC = 79;  // Assuming 80 MHz clock, prescaler at 80 for 1 MHz timer clock
    TIM3->PSC = 79;
    TIM1->ARR = 999;  // Auto-reload at 1000 for 1 kHz PWM frequency
    TIM3->ARR = 999;
    
    // Enable TIM1 and TIM3
    TIM1->CR1 |= TIM_CR1_CEN;
    TIM3->CR1 |= TIM_CR1_CEN;
}

// Function to configure GPIO pins for the motor driver
void configure_motor_pins() {
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOCEN;  // Enable Clock for GPIOC
    GPIOC->MODER &= ~((0x3 << (0 * 2)) | (0x3 << (1 * 2)) | (0x3 << (2 * 2)) | (0x3 << (3 * 2)));  // Clear mode bits
    GPIOC->MODER |= (0x2 << (0 * 2)) | (0x2 << (1 * 2)) | (0x2 << (2 * 2)) | (0x2 << (3 * 2));  // Set mode to AF (alternate function)
    GPIOC->AFR[0] |= (1 << (0 * 4)) | (1 << (1 * 4)) | (1 << (2 * 4)) | (1 << (3 * 4));  // Set AF1 for TIM1/TIM3 channels
}

// Motor control functions using PWM adjustments
void motor_stop() {
    TIM1->CCR1 = 0;  // Set duty cycle to 0% (no power)
    TIM3->CCR1 = 0;
}

void motor_forward() {
    TIM1->CCR1 = 500;  // 50% duty cycle
    TIM3->CCR1 = 0;
}

void motor_backward() {
    TIM1->CCR1 = 0;
    TIM3->CCR1 = 500;  // 50% duty cycle
}

void motor_turn_left() {
    TIM1->CCR1 = 250;  // 25% duty cycle
    TIM3->CCR1 = 500;  // 50% duty cycle
}

void motor_turn_right() {
    TIM1->CCR1 = 500;  // 50% duty cycle
    TIM3->CCR1 = 250;  // 25% duty cycle
}

void control_logic(float left_distance, float right_distance, float current_distance) {
    if (current_distance < 10.0) {
        motor_stop();
        delay_ms(300);  // Delay for 300 ms
        motor_backward();  // Reverse the robot
        delay_ms(1000);  // Move backward for a short duration

        // Check distances to decide the next move
        if (left_distance > right_distance) {
            motor_turn_left();
        } else {
            motor_turn_right();
        }
    } else {
        motor_forward();
    }
}

